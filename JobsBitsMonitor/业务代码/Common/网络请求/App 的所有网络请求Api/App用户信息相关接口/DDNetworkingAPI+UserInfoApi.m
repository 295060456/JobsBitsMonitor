//
//  DDNetworkingAPI+UserInfoApi.m
//  MonkeyKingVideo
//
//  Created by Jobs on 2020/12/10.
//  Copyright © 2020 MonkeyKingVideo. All rights reserved.
//

#import "DDNetworkingAPI+UserInfoApi.h"
 

@implementation DDNetworkingAPI (UserInfoApi)

#pragma mark —— App用户信息相关接口
/// 绑定手机号
NSString *bindPhonePOST;
+(void)bindPhonePOST:(id _Nullable)parameters
        successBlock:(MKDataBlock _Nullable)successBlock{
//    NSDictionary *parameterss = @{};
//    NSDictionary *headers = @{};
    
    [ZBRequestManager requestWithConfig:^(ZBURLRequest * _Nullable request) {

        request.server = NSObject.BaseUrl;
        request.url = [request.server stringByAppendingString:NSObject.bindPhonePOST.url];
        
        NSLog(@"request.URLString = %@",request.url);
        
        request.methodType = ZBMethodTypePOST;//默认为GET
        request.apiType = ZBRequestTypeRefresh;//（默认为ZBRequestTypeRefresh 不读取缓存，不存储缓存）
        request.parameters = parameters;//与公共配置 Parameters 兼容
//        request.headers = headers;//与公共配置 Headers 兼容
        request.retryCount = 1;//请求失败 单次请求 重新连接次数 优先级大于 全局设置，不影响其他请求设置
        request.timeoutInterval = 10;//默认30 //优先级 高于 公共配置,不影响其他请求设置
        if (![NSString isNullString:[DataManager sharedInstance].tag]) {
            request.userInfo = @{@"info":[DataManager sharedInstance].tag};//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        };//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        
        {
//            request.filtrationCacheKey = @[@""];//与公共配置 filtrationCacheKey 兼容
//            request.requestSerializer = ZBJSONRequestSerializer; //单次请求设置 请求格式 默认JSON，优先级大于 公共配置，不影响其他请求设置
//            request.responseSerializer = ZBJSONResponseSerializer; //单次请求设置 响应格式 默认JSON，优先级大于 公共配置,不影响其他请求设置
           
            /**
             多次请求同一个接口 保留第一次或最后一次请求结果 只在请求时有用  读取缓存无效果。默认ZBResponseKeepNone 什么都不做
             使用场景是在 重复点击造成的 多次请求，如发帖，评论，搜索等业务
             */
//            request.keepType=ZBResponseKeepNone;
        }//一些临时的其他的配置
        
    }progress:^(NSProgress * _Nullable progress){
        NSLog(@"进度 = %f",progress.fractionCompleted * 100);
    }success:^(id  _Nullable responseObject,
               ZBURLRequest * _Nullable request){
        if ([responseObject isKindOfClass:NSDictionary.class]) {
            NSDictionary *dataDic = (NSDictionary *)responseObject;
            DDResponseModel *model = [DDResponseModel mj_objectWithKeyValues:dataDic];
            // 公共请求错误直接抛出
            if (model.code != HTTPResponseCodeSuccess) {
                [WHToast toastMsg:model.msg];
            }else{
                if (successBlock) {
                    successBlock(model);
                }
            }
        }else{
            [WHToast toastMsg:[@"异常接口" stringByAppendingString:NSObject.bindPhonePOST.funcName]];
        }
    }failure:^(NSError * _Nullable error){
        NSLog(@"error = %@",error);
    }finished:^(id  _Nullable responseObject,
                NSError * _Nullable error,
                ZBURLRequest * _Nullable request){
        NSLog(@"请求完成 userInfo:%@",request.userInfo);
    }];
}
/// 校验是否有权限
NSString *checkHadRoleGET;
+(void)checkHadRoleGET:(id _Nullable)parameters
          successBlock:(MKDataBlock _Nullable)successBlock
          failureBlock:(MKDataBlock _Nullable)failureBlock{
//    NSDictionary *parameterss = @{};
//    NSDictionary *headers = @{};
    
    [ZBRequestManager requestWithConfig:^(ZBURLRequest * _Nullable request) {

        request.server = NSObject.BaseUrl;
        request.url = [request.server stringByAppendingString:NSObject.checkHadRoleGET.url];
        
        NSLog(@"request.URLString = %@",request.url);
        
        request.methodType = ZBMethodTypeGET;//默认为GET
        request.apiType = ZBRequestTypeRefresh;//（默认为ZBRequestTypeRefresh 不读取缓存，不存储缓存）
        request.parameters = parameters;//与公共配置 Parameters 兼容
//        request.headers = headers;//与公共配置 Headers 兼容
        request.retryCount = 1;//请求失败 单次请求 重新连接次数 优先级大于 全局设置，不影响其他请求设置
        request.timeoutInterval = 10;//默认30 //优先级 高于 公共配置,不影响其他请求设置
        if (![NSString isNullString:[DataManager sharedInstance].tag]) {
            request.userInfo = @{@"info":[DataManager sharedInstance].tag};//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        };//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        
        {
//            request.filtrationCacheKey = @[@""];//与公共配置 filtrationCacheKey 兼容
//            request.requestSerializer = ZBJSONRequestSerializer; //单次请求设置 请求格式 默认JSON，优先级大于 公共配置，不影响其他请求设置
//            request.responseSerializer = ZBJSONResponseSerializer; //单次请求设置 响应格式 默认JSON，优先级大于 公共配置,不影响其他请求设置
           
            /**
             多次请求同一个接口 保留第一次或最后一次请求结果 只在请求时有用  读取缓存无效果。默认ZBResponseKeepNone 什么都不做
             使用场景是在 重复点击造成的 多次请求，如发帖，评论，搜索等业务
             */
//            request.keepType=ZBResponseKeepNone;
        }//一些临时的其他的配置
        
    }progress:^(NSProgress * _Nullable progress){
        NSLog(@"进度 = %f",progress.fractionCompleted * 100);
    }success:^(id  _Nullable responseObject,
               ZBURLRequest * _Nullable request){
        if ([responseObject isKindOfClass:NSDictionary.class]) {
            NSDictionary *dataDic = (NSDictionary *)responseObject;
            DDResponseModel *model = [DDResponseModel mj_objectWithKeyValues:dataDic];
            // 公共请求错误直接抛出
            if (model.code != HTTPResponseCodeSuccess) {
                [WHToast toastMsg:model.msg];
            }else{
                if (successBlock) {
                    successBlock(model);
                }
            }
        }else{
            [WHToast toastMsg:[@"异常接口" stringByAppendingString:NSObject.checkHadRoleGET.funcName]];
        }
    }failure:^(NSError * _Nullable error){
        if (failureBlock) {
            failureBlock(error);
        }
        NSLog(@"error = %@",error);
    }finished:^(id  _Nullable responseObject,
                NSError * _Nullable error,
                ZBURLRequest * _Nullable request){
        NSLog(@"请求完成 userInfo:%@",request.userInfo);
    }];
}
/// 系统头像选择
NSString *choiceHeadImagePOST;
+(void)choiceHeadImagePOST:(id _Nullable)parameters
              successBlock:(MKDataBlock _Nullable)successBlock{
//    NSDictionary *parameterss = @{};
//    NSDictionary *headers = @{};
    
    [ZBRequestManager requestWithConfig:^(ZBURLRequest * _Nullable request) {

        request.server = NSObject.BaseUrl;
        request.url = [request.server stringByAppendingString:NSObject.choiceHeadImagePOST.url];
        
        NSLog(@"request.URLString = %@",request.url);
        
        request.methodType = ZBMethodTypePOST;//默认为GET
        request.apiType = ZBRequestTypeRefresh;//（默认为ZBRequestTypeRefresh 不读取缓存，不存储缓存）
        request.parameters = parameters;//与公共配置 Parameters 兼容
//        request.headers = headers;//与公共配置 Headers 兼容
        request.retryCount = 1;//请求失败 单次请求 重新连接次数 优先级大于 全局设置，不影响其他请求设置
        request.timeoutInterval = 10;//默认30 //优先级 高于 公共配置,不影响其他请求设置
        if (![NSString isNullString:[DataManager sharedInstance].tag]) {
            request.userInfo = @{@"info":[DataManager sharedInstance].tag};//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        };//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        
        {
//            request.filtrationCacheKey = @[@""];//与公共配置 filtrationCacheKey 兼容
//            request.requestSerializer = ZBJSONRequestSerializer; //单次请求设置 请求格式 默认JSON，优先级大于 公共配置，不影响其他请求设置
//            request.responseSerializer = ZBJSONResponseSerializer; //单次请求设置 响应格式 默认JSON，优先级大于 公共配置,不影响其他请求设置
           
            /**
             多次请求同一个接口 保留第一次或最后一次请求结果 只在请求时有用  读取缓存无效果。默认ZBResponseKeepNone 什么都不做
             使用场景是在 重复点击造成的 多次请求，如发帖，评论，搜索等业务
             */
//            request.keepType=ZBResponseKeepNone;
        }//一些临时的其他的配置
        
    }progress:^(NSProgress * _Nullable progress){
        NSLog(@"进度 = %f",progress.fractionCompleted * 100);
    }success:^(id  _Nullable responseObject,
               ZBURLRequest * _Nullable request){
        if ([responseObject isKindOfClass:NSDictionary.class]) {
            NSDictionary *dataDic = (NSDictionary *)responseObject;
            DDResponseModel *model = [DDResponseModel mj_objectWithKeyValues:dataDic];
            // 公共请求错误直接抛出
            if (model.code != HTTPResponseCodeSuccess) {
                [WHToast toastMsg:model.msg];
            }else{
                if (successBlock) {
                    successBlock(model);
                }
            }
        }else{
            [WHToast toastMsg:[@"异常接口" stringByAppendingString:NSObject.choiceHeadImagePOST.funcName]];
        }
    }failure:^(NSError * _Nullable error){
        NSLog(@"error = %@",error);
    }finished:^(id  _Nullable responseObject,
                NSError * _Nullable error,
                ZBURLRequest * _Nullable request){
        NSLog(@"请求完成 userInfo:%@",request.userInfo);
    }];
}
/// 进行签到
NSString *doSignPOST;
+(void)doSignPOST:(id _Nullable)parameters
     successBlock:(MKDataBlock _Nullable)successBlock{
//    NSDictionary *parameterss = @{};
//    NSDictionary *headers = @{};
    
    [ZBRequestManager requestWithConfig:^(ZBURLRequest * _Nullable request) {

        request.server = NSObject.BaseUrl;
        request.url = [request.server stringByAppendingString:NSObject.doSignPOST.url];
        
        NSLog(@"request.URLString = %@",request.url);
        
        request.methodType = ZBMethodTypePOST;//默认为GET
        request.apiType = ZBRequestTypeRefresh;//（默认为ZBRequestTypeRefresh 不读取缓存，不存储缓存）
        request.parameters = parameters;//与公共配置 Parameters 兼容
//        request.headers = headers;//与公共配置 Headers 兼容
        request.retryCount = 1;//请求失败 单次请求 重新连接次数 优先级大于 全局设置，不影响其他请求设置
        request.timeoutInterval = 10;//默认30 //优先级 高于 公共配置,不影响其他请求设置
        if (![NSString isNullString:[DataManager sharedInstance].tag]) {
            request.userInfo = @{@"info":[DataManager sharedInstance].tag};//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        };//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        
        {
//            request.filtrationCacheKey = @[@""];//与公共配置 filtrationCacheKey 兼容
//            request.requestSerializer = ZBJSONRequestSerializer; //单次请求设置 请求格式 默认JSON，优先级大于 公共配置，不影响其他请求设置
//            request.responseSerializer = ZBJSONResponseSerializer; //单次请求设置 响应格式 默认JSON，优先级大于 公共配置,不影响其他请求设置
           
            /**
             多次请求同一个接口 保留第一次或最后一次请求结果 只在请求时有用  读取缓存无效果。默认ZBResponseKeepNone 什么都不做
             使用场景是在 重复点击造成的 多次请求，如发帖，评论，搜索等业务
             */
//            request.keepType=ZBResponseKeepNone;
        }//一些临时的其他的配置
        
    }progress:^(NSProgress * _Nullable progress){
        NSLog(@"进度 = %f",progress.fractionCompleted * 100);
    }success:^(id  _Nullable responseObject,
               ZBURLRequest * _Nullable request){
        if ([responseObject isKindOfClass:NSDictionary.class]) {
            NSDictionary *dataDic = (NSDictionary *)responseObject;
            DDResponseModel *model = [DDResponseModel mj_objectWithKeyValues:dataDic];
            // 公共请求错误直接抛出
            if (model.code != HTTPResponseCodeSuccess) {
                [WHToast toastMsg:model.msg];
            }else{
                if (successBlock) {
                    successBlock(model);
                }
            }
        }else{
            [WHToast toastMsg:[@"异常接口" stringByAppendingString:NSObject.doSignPOST.funcName]];
        }
    }failure:^(NSError * _Nullable error){
        NSLog(@"error = %@",error);
    }finished:^(id  _Nullable responseObject,
                NSError * _Nullable error,
                ZBURLRequest * _Nullable request){
        NSLog(@"请求完成 userInfo:%@",request.userInfo);
    }];
}
/// 系统头像列表
NSString *headImageListGET;
+(void)headImageListGET:(id _Nullable)parameters
           successBlock:(MKDataBlock _Nullable)successBlock
           failureBlock:(MKDataBlock _Nullable)failureBlock{
//    NSDictionary *parameterss = @{};
//    NSDictionary *headers = @{};
    
    [ZBRequestManager requestWithConfig:^(ZBURLRequest * _Nullable request) {

        request.server = NSObject.BaseUrl;
        request.url = [request.server stringByAppendingString:NSObject.headImageListGET.url];
        
        NSLog(@"request.URLString = %@",request.url);
        
        request.methodType = ZBMethodTypeGET;//默认为GET
        request.apiType = ZBRequestTypeRefresh;//（默认为ZBRequestTypeRefresh 不读取缓存，不存储缓存）
        request.parameters = parameters;//与公共配置 Parameters 兼容
//        request.headers = headers;//与公共配置 Headers 兼容
        request.retryCount = 1;//请求失败 单次请求 重新连接次数 优先级大于 全局设置，不影响其他请求设置
        request.timeoutInterval = 10;//默认30 //优先级 高于 公共配置,不影响其他请求设置
        if (![NSString isNullString:[DataManager sharedInstance].tag]) {
            request.userInfo = @{@"info":[DataManager sharedInstance].tag};//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        };//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        
        {
//            request.filtrationCacheKey = @[@""];//与公共配置 filtrationCacheKey 兼容
//            request.requestSerializer = ZBJSONRequestSerializer; //单次请求设置 请求格式 默认JSON，优先级大于 公共配置，不影响其他请求设置
//            request.responseSerializer = ZBJSONResponseSerializer; //单次请求设置 响应格式 默认JSON，优先级大于 公共配置,不影响其他请求设置
           
            /**
             多次请求同一个接口 保留第一次或最后一次请求结果 只在请求时有用  读取缓存无效果。默认ZBResponseKeepNone 什么都不做
             使用场景是在 重复点击造成的 多次请求，如发帖，评论，搜索等业务
             */
//            request.keepType=ZBResponseKeepNone;
        }//一些临时的其他的配置
        
    }progress:^(NSProgress * _Nullable progress){
        NSLog(@"进度 = %f",progress.fractionCompleted * 100);
    }success:^(id  _Nullable responseObject,
               ZBURLRequest * _Nullable request){
        if ([responseObject isKindOfClass:NSDictionary.class]) {
            NSDictionary *dataDic = (NSDictionary *)responseObject;
            DDResponseModel *model = [DDResponseModel mj_objectWithKeyValues:dataDic];
            // 公共请求错误直接抛出
            if (model.code != HTTPResponseCodeSuccess) {
                [WHToast toastMsg:model.msg];
            }else{
                if (successBlock) {
                    successBlock(model);
                }
            }
        }else{
            [WHToast toastMsg:[@"异常接口" stringByAppendingString:NSObject.headImageListGET.funcName]];
        }
    }failure:^(NSError * _Nullable error){
        NSLog(@"error = %@",error);
        if (failureBlock) {
            failureBlock(error);
        }
    }finished:^(id  _Nullable responseObject,
                NSError * _Nullable error,
                ZBURLRequest * _Nullable request){
        NSLog(@"请求完成 userInfo:%@",request.userInfo);
    }];
}
/// 邀请好友
NSString *userInfoInviteFriendPOST;
+(void)userInfoInviteFriendPOST:(id _Nullable)parameters
                   successBlock:(MKDataBlock _Nullable)successBlock{
//    NSDictionary *parameterss = @{};
//    NSDictionary *headers = @{};
    
    [ZBRequestManager requestWithConfig:^(ZBURLRequest * _Nullable request) {

        request.server = NSObject.BaseUrl;
        request.url = [request.server stringByAppendingString:NSObject.userInfoInviteFriendPOST.url];
        
        NSLog(@"request.URLString = %@",request.url);
        
        request.methodType = ZBMethodTypePOST;//默认为GET
        request.apiType = ZBRequestTypeRefresh;//（默认为ZBRequestTypeRefresh 不读取缓存，不存储缓存）
        request.parameters = parameters;//与公共配置 Parameters 兼容
//        request.headers = headers;//与公共配置 Headers 兼容
        request.retryCount = 1;//请求失败 单次请求 重新连接次数 优先级大于 全局设置，不影响其他请求设置
        request.timeoutInterval = 10;//默认30 //优先级 高于 公共配置,不影响其他请求设置
        if (![NSString isNullString:[DataManager sharedInstance].tag]) {
            request.userInfo = @{@"info":[DataManager sharedInstance].tag};//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        };//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        
        {
//            request.filtrationCacheKey = @[@""];//与公共配置 filtrationCacheKey 兼容
//            request.requestSerializer = ZBJSONRequestSerializer; //单次请求设置 请求格式 默认JSON，优先级大于 公共配置，不影响其他请求设置
//            request.responseSerializer = ZBJSONResponseSerializer; //单次请求设置 响应格式 默认JSON，优先级大于 公共配置,不影响其他请求设置
           
            /**
             多次请求同一个接口 保留第一次或最后一次请求结果 只在请求时有用  读取缓存无效果。默认ZBResponseKeepNone 什么都不做
             使用场景是在 重复点击造成的 多次请求，如发帖，评论，搜索等业务
             */
//            request.keepType=ZBResponseKeepNone;
        }//一些临时的其他的配置
        
    }progress:^(NSProgress * _Nullable progress){
        NSLog(@"进度 = %f",progress.fractionCompleted * 100);
    }success:^(id  _Nullable responseObject,
               ZBURLRequest * _Nullable request){
        if ([responseObject isKindOfClass:NSDictionary.class]) {
            NSDictionary *dataDic = (NSDictionary *)responseObject;
            DDResponseModel *model = [DDResponseModel mj_objectWithKeyValues:dataDic];
            // 公共请求错误直接抛出
            if (model.code != HTTPResponseCodeSuccess) {
                [WHToast toastMsg:model.msg];
            }else{
                if (successBlock) {
                    successBlock(model);
                }
            }
        }else{
            [WHToast toastMsg:[@"异常接口" stringByAppendingString:NSObject.userInfoInviteFriendPOST.funcName]];
        }
    }failure:^(NSError * _Nullable error){
        NSLog(@"error = %@",error);
    }finished:^(id  _Nullable responseObject,
                NSError * _Nullable error,
                ZBURLRequest * _Nullable request){
        NSLog(@"请求完成 userInfo:%@",request.userInfo);
    }];
}
/// 邀请任务数据展示
NSString *userInfoListGET;
+(void)userInfoListGET:(id _Nullable)parameters
          successBlock:(MKDataBlock _Nullable)successBlock{
//    NSDictionary *parameterss = @{};
//    NSDictionary *headers = @{};
    
    [ZBRequestManager requestWithConfig:^(ZBURLRequest * _Nullable request) {

        request.server = NSObject.BaseUrl;
        request.url = [request.server stringByAppendingString:NSObject.userInfoListGET.url];
        
        NSLog(@"request.URLString = %@",request.url);
        
        request.methodType = ZBMethodTypeGET;//默认为GET
        request.apiType = ZBRequestTypeRefresh;//（默认为ZBRequestTypeRefresh 不读取缓存，不存储缓存）
        request.parameters = parameters;//与公共配置 Parameters 兼容
//        request.headers = headers;//与公共配置 Headers 兼容
        request.retryCount = 1;//请求失败 单次请求 重新连接次数 优先级大于 全局设置，不影响其他请求设置
        request.timeoutInterval = 10;//默认30 //优先级 高于 公共配置,不影响其他请求设置
        if (![NSString isNullString:[DataManager sharedInstance].tag]) {
            request.userInfo = @{@"info":[DataManager sharedInstance].tag};//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        };//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        
        {
//            request.filtrationCacheKey = @[@""];//与公共配置 filtrationCacheKey 兼容
//            request.requestSerializer = ZBJSONRequestSerializer; //单次请求设置 请求格式 默认JSON，优先级大于 公共配置，不影响其他请求设置
//            request.responseSerializer = ZBJSONResponseSerializer; //单次请求设置 响应格式 默认JSON，优先级大于 公共配置,不影响其他请求设置
           
            /**
             多次请求同一个接口 保留第一次或最后一次请求结果 只在请求时有用  读取缓存无效果。默认ZBResponseKeepNone 什么都不做
             使用场景是在 重复点击造成的 多次请求，如发帖，评论，搜索等业务
             */
//            request.keepType=ZBResponseKeepNone;
        }//一些临时的其他的配置
        
    }progress:^(NSProgress * _Nullable progress){
        NSLog(@"进度 = %f",progress.fractionCompleted * 100);
    }success:^(id  _Nullable responseObject,
               ZBURLRequest * _Nullable request){
        if ([responseObject isKindOfClass:NSDictionary.class]) {
            NSDictionary *dataDic = (NSDictionary *)responseObject;
            DDResponseModel *model = [DDResponseModel mj_objectWithKeyValues:dataDic];
            // 公共请求错误直接抛出
            if (model.code != HTTPResponseCodeSuccess) {
                [WHToast toastMsg:model.msg];
            }else{
                if (successBlock) {
                    successBlock(model);
                }
            }
        }else{
            [WHToast toastMsg:[@"异常接口" stringByAppendingString:NSObject.userInfoListGET.funcName]];
        }
    }failure:^(NSError * _Nullable error){
        NSLog(@"error = %@",error);
    }finished:^(id  _Nullable responseObject,
                NSError * _Nullable error,
                ZBURLRequest * _Nullable request){
        NSLog(@"请求完成 userInfo:%@",request.userInfo);
    }];
}
/// 客服QQ列表 GET
NSString *userInfoQQListGET;
+(void)userInfoQQListGET:(id _Nullable)parameters
            successBlock:(MKDataBlock _Nullable)successBlock
            failureBlock:(MKDataBlock _Nullable)failureBlock{
//    NSDictionary *parameterss = @{};
//    NSDictionary *headers = @{};
    
    [ZBRequestManager requestWithConfig:^(ZBURLRequest * _Nullable request) {

        request.server = NSObject.BaseUrl;
        request.url = [request.server stringByAppendingString:NSObject.userInfoQQListGET.url];
        
        NSLog(@"request.URLString = %@",request.url);
        
        request.methodType = ZBMethodTypeGET;//默认为GET
        request.apiType = ZBRequestTypeRefresh;//（默认为ZBRequestTypeRefresh 不读取缓存，不存储缓存）
        request.parameters = parameters;//与公共配置 Parameters 兼容
//        request.headers = headers;//与公共配置 Headers 兼容
        request.retryCount = 1;//请求失败 单次请求 重新连接次数 优先级大于 全局设置，不影响其他请求设置
        request.timeoutInterval = 10;//默认30 //优先级 高于 公共配置,不影响其他请求设置
        if (![NSString isNullString:[DataManager sharedInstance].tag]) {
            request.userInfo = @{@"info":[DataManager sharedInstance].tag};//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        };//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        
        {
//            request.filtrationCacheKey = @[@""];//与公共配置 filtrationCacheKey 兼容
//            request.requestSerializer = ZBJSONRequestSerializer; //单次请求设置 请求格式 默认JSON，优先级大于 公共配置，不影响其他请求设置
//            request.responseSerializer = ZBJSONResponseSerializer; //单次请求设置 响应格式 默认JSON，优先级大于 公共配置,不影响其他请求设置
           
            /**
             多次请求同一个接口 保留第一次或最后一次请求结果 只在请求时有用  读取缓存无效果。默认ZBResponseKeepNone 什么都不做
             使用场景是在 重复点击造成的 多次请求，如发帖，评论，搜索等业务
             */
//            request.keepType=ZBResponseKeepNone;
        }//一些临时的其他的配置
        
    }progress:^(NSProgress * _Nullable progress){
        NSLog(@"进度 = %f",progress.fractionCompleted * 100);
    }success:^(id  _Nullable responseObject,
               ZBURLRequest * _Nullable request){
        if ([responseObject isKindOfClass:NSDictionary.class]) {
            NSDictionary *dataDic = (NSDictionary *)responseObject;
            DDResponseModel *model = [DDResponseModel mj_objectWithKeyValues:dataDic];
            // 公共请求错误直接抛出
            if (model.code != HTTPResponseCodeSuccess) {
                [WHToast toastMsg:model.msg];
            }else{
                if (successBlock) {
                    successBlock(model);
                }
            }
        }else{
            [WHToast toastMsg:[@"异常接口" stringByAppendingString:NSObject.userInfoQQListGET.funcName]];
        }
    }failure:^(NSError * _Nullable error){
        NSLog(@"error = %@",error);
        if (failureBlock) {
            failureBlock(error);
        }
    }finished:^(id  _Nullable responseObject,
                NSError * _Nullable error,
                ZBURLRequest * _Nullable request){
        NSLog(@"请求完成 userInfo:%@",request.userInfo);
    }];
}
/// 滚动数据
NSString *rollDateGET;
+(void)rollDateGET:(id _Nullable)parameters
      successBlock:(MKDataBlock _Nullable)successBlock{
//    NSDictionary *parameterss = @{};
//    NSDictionary *headers = @{};
    
    [ZBRequestManager requestWithConfig:^(ZBURLRequest * _Nullable request) {

        request.server = NSObject.BaseUrl;
        request.url = [request.server stringByAppendingString:NSObject.rollDateGET.url];
        
        NSLog(@"request.URLString = %@",request.url);
        
        request.methodType = ZBMethodTypeGET;//默认为GET
        request.apiType = ZBRequestTypeRefresh;//（默认为ZBRequestTypeRefresh 不读取缓存，不存储缓存）
        request.parameters = parameters;//与公共配置 Parameters 兼容
//        request.headers = headers;//与公共配置 Headers 兼容
        request.retryCount = 1;//请求失败 单次请求 重新连接次数 优先级大于 全局设置，不影响其他请求设置
        request.timeoutInterval = 10;//默认30 //优先级 高于 公共配置,不影响其他请求设置
        if (![NSString isNullString:[DataManager sharedInstance].tag]) {
            request.userInfo = @{@"info":[DataManager sharedInstance].tag};//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        };//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        
        {
//            request.filtrationCacheKey = @[@""];//与公共配置 filtrationCacheKey 兼容
//            request.requestSerializer = ZBJSONRequestSerializer; //单次请求设置 请求格式 默认JSON，优先级大于 公共配置，不影响其他请求设置
//            request.responseSerializer = ZBJSONResponseSerializer; //单次请求设置 响应格式 默认JSON，优先级大于 公共配置,不影响其他请求设置
           
            /**
             多次请求同一个接口 保留第一次或最后一次请求结果 只在请求时有用  读取缓存无效果。默认ZBResponseKeepNone 什么都不做
             使用场景是在 重复点击造成的 多次请求，如发帖，评论，搜索等业务
             */
//            request.keepType=ZBResponseKeepNone;
        }//一些临时的其他的配置
        
    }progress:^(NSProgress * _Nullable progress){
        NSLog(@"进度 = %f",progress.fractionCompleted * 100);
    }success:^(id  _Nullable responseObject,
               ZBURLRequest * _Nullable request){
        if ([responseObject isKindOfClass:NSDictionary.class]) {
            NSDictionary *dataDic = (NSDictionary *)responseObject;
            DDResponseModel *model = [DDResponseModel mj_objectWithKeyValues:dataDic];
            // 公共请求错误直接抛出
            if (model.code != HTTPResponseCodeSuccess) {
                [WHToast toastMsg:model.msg];
            }else{
                if (successBlock) {
                    successBlock(model);
                }
            }
        }else{
            [WHToast toastMsg:[@"异常接口" stringByAppendingString:NSObject.rollDateGET.funcName]];
        }
    }failure:^(NSError * _Nullable error){
        NSLog(@"error = %@",error);
    }finished:^(id  _Nullable responseObject,
                NSError * _Nullable error,
                ZBURLRequest * _Nullable request){
        NSLog(@"请求完成 userInfo:%@",request.userInfo);
    }];
}
/// 获取邀请码接口
NSString *userInfoSelectInviteCodePOST;
+(void)userInfoSelectInviteCodePOST:(id _Nullable)parameters
                       successBlock:(MKDataBlock _Nullable)successBlock{
//    NSDictionary *parameterss = @{};
//    NSDictionary *headers = @{};
    
    [ZBRequestManager requestWithConfig:^(ZBURLRequest * _Nullable request) {

        request.server = NSObject.BaseUrl;
        request.url = [request.server stringByAppendingString:NSObject.userInfoSelectInviteCodePOST.url];
        
        NSLog(@"request.URLString = %@",request.url);
        
        request.methodType = ZBMethodTypePOST;//默认为GET
        request.apiType = ZBRequestTypeRefresh;//（默认为ZBRequestTypeRefresh 不读取缓存，不存储缓存）
        request.parameters = parameters;//与公共配置 Parameters 兼容
//        request.headers = headers;//与公共配置 Headers 兼容
        request.retryCount = 1;//请求失败 单次请求 重新连接次数 优先级大于 全局设置，不影响其他请求设置
        request.timeoutInterval = 10;//默认30 //优先级 高于 公共配置,不影响其他请求设置
        if (![NSString isNullString:[DataManager sharedInstance].tag]) {
            request.userInfo = @{@"info":[DataManager sharedInstance].tag};//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        };//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        
        {
//            request.filtrationCacheKey = @[@""];//与公共配置 filtrationCacheKey 兼容
//            request.requestSerializer = ZBJSONRequestSerializer; //单次请求设置 请求格式 默认JSON，优先级大于 公共配置，不影响其他请求设置
//            request.responseSerializer = ZBJSONResponseSerializer; //单次请求设置 响应格式 默认JSON，优先级大于 公共配置,不影响其他请求设置
           
            /**
             多次请求同一个接口 保留第一次或最后一次请求结果 只在请求时有用  读取缓存无效果。默认ZBResponseKeepNone 什么都不做
             使用场景是在 重复点击造成的 多次请求，如发帖，评论，搜索等业务
             */
//            request.keepType=ZBResponseKeepNone;
        }//一些临时的其他的配置
        
    }progress:^(NSProgress * _Nullable progress){
        NSLog(@"进度 = %f",progress.fractionCompleted * 100);
    }success:^(id  _Nullable responseObject,
               ZBURLRequest * _Nullable request){
        if ([responseObject isKindOfClass:NSDictionary.class]) {
            NSDictionary *dataDic = (NSDictionary *)responseObject;
            DDResponseModel *model = [DDResponseModel mj_objectWithKeyValues:dataDic];
            // 公共请求错误直接抛出
            if (model.code != HTTPResponseCodeSuccess) {
                [WHToast toastMsg:model.msg];
            }else{
                if (successBlock) {
                    successBlock(model);
                }
            }
        }else{
            [WHToast toastMsg:[@"异常接口" stringByAppendingString:NSObject.userInfoSelectInviteCodePOST.funcName]];
        }
    }failure:^(NSError * _Nullable error){
        NSLog(@"error = %@",error);
    }finished:^(id  _Nullable responseObject,
                NSError * _Nullable error,
                ZBURLRequest * _Nullable request){
        NSLog(@"请求完成 userInfo:%@",request.userInfo);
    }];
}
/// App首页任务界面，查询用户长短视频观影数
NSString *userInfoSelectVideoCountPOST;
+(void)userInfoSelectVideoCountPOST:(id _Nullable)parameters
                       successBlock:(MKDataBlock _Nullable)successBlock{
//    NSDictionary *parameterss = @{};
//    NSDictionary *headers = @{};
    
    [ZBRequestManager requestWithConfig:^(ZBURLRequest * _Nullable request) {

        request.server = NSObject.BaseUrl;
        request.url = [request.server stringByAppendingString:NSObject.userInfoSelectVideoCountPOST.url];
        
        NSLog(@"request.URLString = %@",request.url);
        
        request.methodType = ZBMethodTypePOST;//默认为GET
        request.apiType = ZBRequestTypeRefresh;//（默认为ZBRequestTypeRefresh 不读取缓存，不存储缓存）
        request.parameters = parameters;//与公共配置 Parameters 兼容
//        request.headers = headers;//与公共配置 Headers 兼容
        request.retryCount = 1;//请求失败 单次请求 重新连接次数 优先级大于 全局设置，不影响其他请求设置
        request.timeoutInterval = 10;//默认30 //优先级 高于 公共配置,不影响其他请求设置
        if (![NSString isNullString:[DataManager sharedInstance].tag]) {
            request.userInfo = @{@"info":[DataManager sharedInstance].tag};//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        };//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        
        {
//            request.filtrationCacheKey = @[@""];//与公共配置 filtrationCacheKey 兼容
//            request.requestSerializer = ZBJSONRequestSerializer; //单次请求设置 请求格式 默认JSON，优先级大于 公共配置，不影响其他请求设置
//            request.responseSerializer = ZBJSONResponseSerializer; //单次请求设置 响应格式 默认JSON，优先级大于 公共配置,不影响其他请求设置
           
            /**
             多次请求同一个接口 保留第一次或最后一次请求结果 只在请求时有用  读取缓存无效果。默认ZBResponseKeepNone 什么都不做
             使用场景是在 重复点击造成的 多次请求，如发帖，评论，搜索等业务
             */
//            request.keepType=ZBResponseKeepNone;
        }//一些临时的其他的配置
        
    }progress:^(NSProgress * _Nullable progress){
        NSLog(@"进度 = %f",progress.fractionCompleted * 100);
    }success:^(id  _Nullable responseObject,
               ZBURLRequest * _Nullable request){
        if ([responseObject isKindOfClass:NSDictionary.class]) {
            NSDictionary *dataDic = (NSDictionary *)responseObject;
            DDResponseModel *model = [DDResponseModel mj_objectWithKeyValues:dataDic];
            // 公共请求错误直接抛出
            if (model.code != HTTPResponseCodeSuccess) {
                [WHToast toastMsg:model.msg];
            }else{
                if (successBlock) {
                    successBlock(model);
                }
            }
        }else{
            [WHToast toastMsg:[@"异常接口" stringByAppendingString:NSObject.userInfoSelectVideoCountPOST.funcName]];
        }
    }failure:^(NSError * _Nullable error){
        NSLog(@"error = %@",error);
    }finished:^(id  _Nullable responseObject,
                NSError * _Nullable error,
                ZBURLRequest * _Nullable request){
        NSLog(@"请求完成 userInfo:%@",request.userInfo);
    }];
}
/// 敏感词列表
NSString *userInfoSensitiveListGET;
+(void)userInfoSensitiveListGET:(id _Nullable)parameters
                   successBlock:(MKDataBlock _Nullable)successBlock{
    //    NSDictionary *parameterss = @{};
    //    NSDictionary *headers = @{};
        
        [ZBRequestManager requestWithConfig:^(ZBURLRequest * _Nullable request) {

            request.server = NSObject.BaseUrl;
            request.url = [request.server stringByAppendingString:NSObject.userInfoSensitiveListGET.url];
            
            NSLog(@"request.URLString = %@",request.url);
            
            request.methodType = ZBMethodTypeGET;//默认为GET
            request.apiType = ZBRequestTypeRefresh;//（默认为ZBRequestTypeRefresh 不读取缓存，不存储缓存）
            request.parameters = parameters;//与公共配置 Parameters 兼容
    //        request.headers = headers;//与公共配置 Headers 兼容
            request.retryCount = 1;//请求失败 单次请求 重新连接次数 优先级大于 全局设置，不影响其他请求设置
            request.timeoutInterval = 10;//默认30 //优先级 高于 公共配置,不影响其他请求设置
            if (![NSString isNullString:[DataManager sharedInstance].tag]) {
                request.userInfo = @{@"info":[DataManager sharedInstance].tag};//与公共配置 UserInfo 不兼容 优先级大于 公共配置
            };//与公共配置 UserInfo 不兼容 优先级大于 公共配置
            
            {
    //            request.filtrationCacheKey = @[@""];//与公共配置 filtrationCacheKey 兼容
    //            request.requestSerializer = ZBJSONRequestSerializer; //单次请求设置 请求格式 默认JSON，优先级大于 公共配置，不影响其他请求设置
    //            request.responseSerializer = ZBJSONResponseSerializer; //单次请求设置 响应格式 默认JSON，优先级大于 公共配置,不影响其他请求设置
               
                /**
                 多次请求同一个接口 保留第一次或最后一次请求结果 只在请求时有用  读取缓存无效果。默认ZBResponseKeepNone 什么都不做
                 使用场景是在 重复点击造成的 多次请求，如发帖，评论，搜索等业务
                 */
    //            request.keepType=ZBResponseKeepNone;
            }//一些临时的其他的配置
            
        }progress:^(NSProgress * _Nullable progress){
            NSLog(@"进度 = %f",progress.fractionCompleted * 100);
        }success:^(id  _Nullable responseObject,
                   ZBURLRequest * _Nullable request){
            if ([responseObject isKindOfClass:NSDictionary.class]) {
                NSDictionary *dataDic = (NSDictionary *)responseObject;
                DDResponseModel *model = [DDResponseModel mj_objectWithKeyValues:dataDic];
                // 公共请求错误直接抛出
                if (model.code != HTTPResponseCodeSuccess) {
                    [WHToast toastMsg:model.msg];
                }else{
                    if (successBlock) {
                        successBlock(model);
                    }
                }
            }else{
                [WHToast toastMsg:[@"异常接口" stringByAppendingString:NSObject.userInfoSensitiveListGET.funcName]];
            }
        }failure:^(NSError * _Nullable error){
            NSLog(@"error = %@",error);
        }finished:^(id  _Nullable responseObject,
                    NSError * _Nullable error,
                    ZBURLRequest * _Nullable request){
            NSLog(@"请求完成 userInfo:%@",request.userInfo);
        }];
    }
/// 我的签到列表
NSString *signListGET;
+(void)signListGET:(id _Nullable)parameters
      successBlock:(MKDataBlock _Nullable)successBlock{
//    NSDictionary *parameterss = @{};
//    NSDictionary *headers = @{};
    
    [ZBRequestManager requestWithConfig:^(ZBURLRequest * _Nullable request) {

        request.server = NSObject.BaseUrl;
        request.url = [request.server stringByAppendingString:NSObject.signListGET.url];
        
        NSLog(@"request.URLString = %@",request.url);
        
        request.methodType = ZBMethodTypeGET;//默认为GET
        request.apiType = ZBRequestTypeRefresh;//（默认为ZBRequestTypeRefresh 不读取缓存，不存储缓存）
        request.parameters = parameters;//与公共配置 Parameters 兼容
//        request.headers = headers;//与公共配置 Headers 兼容
        request.retryCount = 1;//请求失败 单次请求 重新连接次数 优先级大于 全局设置，不影响其他请求设置
        request.timeoutInterval = 10;//默认30 //优先级 高于 公共配置,不影响其他请求设置
        if (![NSString isNullString:[DataManager sharedInstance].tag]) {
            request.userInfo = @{@"info":[DataManager sharedInstance].tag};//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        };//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        
        {
//            request.filtrationCacheKey = @[@""];//与公共配置 filtrationCacheKey 兼容
//            request.requestSerializer = ZBJSONRequestSerializer; //单次请求设置 请求格式 默认JSON，优先级大于 公共配置，不影响其他请求设置
//            request.responseSerializer = ZBJSONResponseSerializer; //单次请求设置 响应格式 默认JSON，优先级大于 公共配置,不影响其他请求设置
           
            /**
             多次请求同一个接口 保留第一次或最后一次请求结果 只在请求时有用  读取缓存无效果。默认ZBResponseKeepNone 什么都不做
             使用场景是在 重复点击造成的 多次请求，如发帖，评论，搜索等业务
             */
//            request.keepType=ZBResponseKeepNone;
        }//一些临时的其他的配置
        
    }progress:^(NSProgress * _Nullable progress){
        NSLog(@"进度 = %f",progress.fractionCompleted * 100);
    }success:^(id  _Nullable responseObject,
               ZBURLRequest * _Nullable request){
        if ([responseObject isKindOfClass:NSDictionary.class]) {
            NSDictionary *dataDic = (NSDictionary *)responseObject;
            DDResponseModel *model = [DDResponseModel mj_objectWithKeyValues:dataDic];
            // 公共请求错误直接抛出
            if (model.code != HTTPResponseCodeSuccess) {
                [WHToast toastMsg:model.msg];
            }else{
                if (successBlock) {
                    successBlock(model);
                }
            }
        }else{
            [WHToast toastMsg:[@"异常接口" stringByAppendingString:NSObject.signListGET.funcName]];
        }
    }failure:^(NSError * _Nullable error){
        NSLog(@"error = %@",error);
    }finished:^(id  _Nullable responseObject,
                NSError * _Nullable error,
                ZBURLRequest * _Nullable request){
        NSLog(@"请求完成 userInfo:%@",request.userInfo);
    }];
}
/// 用户更新个人信息-昵称-生日-地区
NSString *userInfoUpdatePOST;
+(void)userInfoUpdatePOST:(id _Nullable)parameters
             successBlock:(MKDataBlock _Nullable)successBlock{
//    NSDictionary *parameterss = @{};
//    NSDictionary *headers = @{};
    
    [ZBRequestManager requestWithConfig:^(ZBURLRequest * _Nullable request) {

        request.server = NSObject.BaseUrl;
        request.url = [request.server stringByAppendingString:NSObject.userInfoUpdatePOST.url];
        
        NSLog(@"request.URLString = %@",request.url);
        
        request.methodType = ZBMethodTypePOST;//默认为GET
        request.apiType = ZBRequestTypeRefresh;//（默认为ZBRequestTypeRefresh 不读取缓存，不存储缓存）
        request.parameters = parameters;//与公共配置 Parameters 兼容
//        request.headers = headers;//与公共配置 Headers 兼容
        request.retryCount = 1;//请求失败 单次请求 重新连接次数 优先级大于 全局设置，不影响其他请求设置
        request.timeoutInterval = 10;//默认30 //优先级 高于 公共配置,不影响其他请求设置
        request.requestSerializer = ZBJSONRequestSerializer;
        
//       @property (nonatomic,assign) ZBRequestSerializerType requestSerializer;
//       @property (nonatomic,assign) ZBResponseSerializerType responseSerializer;
        
        if (![NSString isNullString:[DataManager sharedInstance].tag]) {
            request.userInfo = @{@"info":[DataManager sharedInstance].tag};//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        };//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        
        {
//            request.filtrationCacheKey = @[@""];//与公共配置 filtrationCacheKey 兼容
//            request.requestSerializer = ZBJSONRequestSerializer; //单次请求设置 请求格式 默认JSON，优先级大于 公共配置，不影响其他请求设置
//            request.responseSerializer = ZBJSONResponseSerializer; //单次请求设置 响应格式 默认JSON，优先级大于 公共配置,不影响其他请求设置
           
            /**
             多次请求同一个接口 保留第一次或最后一次请求结果 只在请求时有用  读取缓存无效果。默认ZBResponseKeepNone 什么都不做
             使用场景是在 重复点击造成的 多次请求，如发帖，评论，搜索等业务
             */
//            request.keepType=ZBResponseKeepNone;
        }//一些临时的其他的配置
        
    }progress:^(NSProgress * _Nullable progress){
        NSLog(@"进度 = %f",progress.fractionCompleted * 100);
    }success:^(id  _Nullable responseObject,
               ZBURLRequest * _Nullable request){
        if ([responseObject isKindOfClass:NSDictionary.class]) {
            NSDictionary *dataDic = (NSDictionary *)responseObject;
            DDResponseModel *model = [DDResponseModel mj_objectWithKeyValues:dataDic];
            // 公共请求错误直接抛出
            if (model.code != HTTPResponseCodeSuccess) {
                [WHToast toastMsg:model.msg];
            }else{
                if (successBlock) {
                    successBlock(model);
                }
            }
        }else{
            [WHToast toastMsg:[@"异常接口" stringByAppendingString:NSObject.userInfoUpdatePOST.funcName]];
        }
    }failure:^(NSError * _Nullable error){
        NSLog(@"error = %@",error);
    }finished:^(id  _Nullable responseObject,
                NSError * _Nullable error,
                ZBURLRequest * _Nullable request){
        NSLog(@"请求完成 userInfo:%@",request.userInfo);
    }];
}
/// 上传头像
NSString *uploadImagePOST;
+(void)uploadImagePOST:(id _Nullable)parameters
      uploadImageDatas:(NSMutableArray<UIImage *> *)uploadImageDatas
          successBlock:(MKDataBlock _Nullable)successBlock
          failureBlock:(MKDataBlock _Nullable)failureBlock{
    [WHToast toastLoadingMsg:@"头像上传中...请稍后"];
    NSMutableArray *uploadDatas = NSMutableArray.array;
    for (int i = 0; i < uploadImageDatas.count; i++) {
        UIImage *image = uploadImageDatas[i];
        NSData *imageData = UIImageJPEGRepresentation(image, 1.0);
        NSInteger time = NSDate.date.timeIntervalSince1970 * 1000;
        NSString *fileName = [NSString stringWithFormat:@"%ld_%u.jpeg",time,arc4random() / 1000];
        ZBUploadData *zbdata = [ZBUploadData formDataWithName:@"file"
                                                     fileName:fileName
                                                     mimeType:@"image/jpeg"
                                                     fileData:imageData];
        [uploadDatas addObject:zbdata];
    }
    [ZBRequestManager requestWithConfig:^(ZBURLRequest * request) {
        request.server = NSObject.BaseUrl;
        request.url = [request.server stringByAppendingString:NSObject.uploadImagePOST.url];
        NSLog(@"request.URLString = %@",request.url);
        request.methodType = ZBMethodTypeUpload;
        request.apiType = ZBRequestTypeRefresh;//（默认为ZBRequestTypeRefresh 不读取缓存，不存储缓存）
//        request.parameters = parameters;//与公共配置 Parameters 兼容
//        request.headers = headers;//与公共配置Headers 兼容
        request.retryCount = 1;//请求失败 单次请求 重新连接次数 优先级大于 全局设置，不影响其他请求设置
        request.timeoutInterval = 120;//默认30 //优先级 高于 公共配置,不影响其他请求设置
        request.requestSerializer = ZBHTTPRequestSerializer;
        request.uploadDatas = uploadDatas;
        if (![NSString isNullString:[DataManager sharedInstance].tag]) {
            request.userInfo = @{@"info":[DataManager sharedInstance].tag};//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        };//与公共配置 UserInfo 不兼容 优先级大于 公共配置
    } progress:^(NSProgress * _Nullable progress) {
        NSLog(@"onProgress: %.2f", 100.f * progress.completedUnitCount/progress.totalUnitCount);
    } success:^(id  responseObject,ZBURLRequest * request) {
        if ([responseObject isKindOfClass:NSDictionary.class]) {
            [WHToast toastHide];
            NSDictionary *dataDic = (NSDictionary *)responseObject;
            DDResponseModel *model = [DDResponseModel mj_objectWithKeyValues:dataDic];
            // 公共请求错误直接抛出
            if (model.code != HTTPResponseCodeSuccess) {
                [WHToast toastMsg:model.msg];
            }else{
                if (successBlock) {
                    successBlock(model);
                }
            }
        }else{
            [WHToast toastMsg:[@"异常接口" stringByAppendingString:NSObject.uploadImagePOST.funcName]];
        }
    } failure:^(NSError * _Nullable error) {
        NSLog(@"error: %@", error);
        [WHToast toastHide];
        if (failureBlock) {
            failureBlock(error);
        }
    }];
}
/// App端查看用户详情
NSString *userInfoGET;
+(void)userInfoGET:(id _Nullable)parameters
      successBlock:(MKDataBlock _Nullable)successBlock{
//    NSDictionary *parameterss = @{};
//    NSDictionary *headers = @{};
    
    [ZBRequestManager requestWithConfig:^(ZBURLRequest * _Nullable request) {

        request.server = NSObject.BaseUrl;
        request.url = [request.server stringByAppendingString:NSObject.userInfoGET.url];
        
        NSLog(@"request.URLString = %@",request.url);
        
        request.methodType = ZBMethodTypeGET;//默认为GET
        request.apiType = ZBRequestTypeRefresh;//（默认为ZBRequestTypeRefresh 不读取缓存，不存储缓存）
        request.parameters = parameters;//与公共配置 Parameters 兼容
//        request.headers = headers;//与公共配置 Headers 兼容
        request.retryCount = 1;//请求失败 单次请求 重新连接次数 优先级大于 全局设置，不影响其他请求设置
        request.timeoutInterval = 10;//默认30 //优先级 高于 公共配置,不影响其他请求设置
        if (![NSString isNullString:[DataManager sharedInstance].tag]) {
            request.userInfo = @{@"info":[DataManager sharedInstance].tag};//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        };//与公共配置 UserInfo 不兼容 优先级大于 公共配置
        
        {
//            request.filtrationCacheKey = @[@""];//与公共配置 filtrationCacheKey 兼容
//            request.requestSerializer = ZBJSONRequestSerializer; //单次请求设置 请求格式 默认JSON，优先级大于 公共配置，不影响其他请求设置
//            request.responseSerializer = ZBJSONResponseSerializer; //单次请求设置 响应格式 默认JSON，优先级大于 公共配置,不影响其他请求设置
           
            /**
             多次请求同一个接口 保留第一次或最后一次请求结果 只在请求时有用  读取缓存无效果。默认ZBResponseKeepNone 什么都不做
             使用场景是在 重复点击造成的 多次请求，如发帖，评论，搜索等业务
             */
//            request.keepType=ZBResponseKeepNone;
        }//一些临时的其他的配置
        
    }progress:^(NSProgress * _Nullable progress){
        NSLog(@"进度 = %f",progress.fractionCompleted * 100);
    }success:^(id  _Nullable responseObject,
               ZBURLRequest * _Nullable request){
        if ([responseObject isKindOfClass:NSDictionary.class]) {
            NSDictionary *dataDic = (NSDictionary *)responseObject;
            DDResponseModel *model = [DDResponseModel mj_objectWithKeyValues:dataDic];
            // 公共请求错误直接抛出
            if (model.code != HTTPResponseCodeSuccess) {
                [WHToast toastMsg:model.msg];
            }else{
                if (successBlock) {
                    successBlock(model);
                }
            }
        }else{
            [WHToast toastMsg:[@"异常接口" stringByAppendingString:NSObject.userInfoGET.funcName]];
        }
    }failure:^(NSError * _Nullable error){
        NSLog(@"error = %@",error);
    }finished:^(id  _Nullable responseObject,
                NSError * _Nullable error,
                ZBURLRequest * _Nullable request){
        NSLog(@"请求完成 userInfo:%@",request.userInfo);
    }];
}

@end
